export declare const languages: {
	en: Language;
	mi: Language;
	de: Language;
};
export declare const measurements: {
	ns: number;
	us: number;
	ms: number;
	s: number;
	m: number;
	h: number;
	d: number;
	w: number;
	mo: number;
	y: number;
	dec: number;
	c: number;
	kyr: number;
};
export declare const ms: {
	/**
     * Convert milliseconds to a human readable string.
     * @param input Number of milliseconds.
     * @param options Options for formatting.
     * @example
     * ms(13572468) // => '3 hours 46 minutes and 12 seconds'
     *
     * ms(13572468, { includeMs: true }) // => '3 hours 46 minutes 12 seconds and 468 milliseconds'
     * ms(13572.468, { includeSubMs: true }) // => '13 seconds 572 milliseconds and 468 microseconds'
     *
     * ms(13572468, { roundUp: true }) // => '4 hours'
     * ms(13572468, { shortFormat: true }) // => '3h 46m 12s'
     * ms(13572468, { insertCommas: true }) // => '3 hours, 46 minutes, and 12 seconds'
     */
	(input: number, options?: FormatOptions): ReturnType<typeof format>;
	/**
     * Convert milliseconds to a human readable string.
     * @param input Number of milliseconds.
     * @param language Language key.
     * @param options Options for formatting.
     * @example
     * ms(13572468, 'mi') // => '3 hāora 46 meneti me te 12 hēkona'
     *
     * ms(13572468, 'mi', { includeMs: true }) // => '3 hāora 46 meneti 12 hēkona me te 468 hēkona miri'
     * ms(13572.468, 'mi', { includeSubMs: true }) // => '13 hēkona 572 hēkona miri me te 468 hēkona miriona'
     *
     * ms(13572468, 'mi', { roundUp: true }) // => '4 hāora'
     * ms(13572468, 'mi', { shortFormat: true }) // => '3 hāora 46 meneti me te 12 hēkona'
     * ms(13572468, 'mi', { insertCommas: true }) // => '3 hāora, 46 meneti, me te 12 hēkona'
     */
	(input: number, language: LanguageKey, options?: FormatOptions): ReturnType<typeof format>;
	/**
     * Parse a human readable timeframe string to milliseconds.
     * @param input Timeframe string.
     * @param options Options for parsing.
     * @example
     * ms('2 seconds') // => 2000
     * ms('2 minutes and 30 seconds') // => 150000
     * ms('1.5 days and 1.5 hours') // => 135000000
     *
     * ms('2 hours - 30 minutes') // => 5400000
     * ms('1 day * 365') // => 31536000000
     * ms('1.5 days + 1.5 hours') // => 135000000
     *
     * ms('1 week - 3 days * 2') // => 86400000
     * ms('(1 week - 3 days) * 2') // => 691200000
     */
	(input: string, options?: ParseOptions): ReturnType<typeof parse>;
	/**
     * Parse a human readable timeframe string to milliseconds.
     * @param input Timeframe string.
     * @param language Language key.
     * @param options Options for parsing.
     * @example
     * ms('2 hēkona') // => 2000
     * ms('2 meneti me te 30 hēkona') // => 150000
     * ms('1.5 ra me te 1.5 hāora') // => 135000000
     *
     * ms('2 hāora - 30 meneti') // => 5400000
     * ms('1 rangi * 365') // => 31536000000
     * ms('1.5 ra + 1.5 hāora') // => 135000000
     *
     * ms('1 wiki - 3 ra * 2') // => 86400000
     * ms('(1 wiki - 3 ra) * 2') // => 691200000
     */
	(input: string, language: LanguageKey, options?: ParseOptions): ReturnType<typeof parse>;
	/**
     * Create a new instance with a new default language.
     * @param language Language key.
     * @example
     * const ms = require('enhanced-ms')('mi');
     * ms(2000) // => '2 hēkona'
     * @example
     * const ms = require('enhanced-ms');
     * ms(2000) // => '2 seconds'
     * const newMs = ms('mi');
     * newMs(2000) // => '2 hēkona'
     */
	(language: LanguageKey): typeof ms;
	/**
     * Create a new instance with new default options.
     * @param options Options for parsing and formatting.
     * @example
     * const ms = require('enhanced-ms')({ roundUp: true });
     * ms(13572468) // => '4 hours'
     * @example
     * const ms = require('enhanced-ms');
     * ms(13572468) // => '3 hours 46 minutes and 12 seconds'
     * const newMs = ms({ roundUp: true });
     * newMs(13572468) // => '4 hours'
     */
	(options: CombinedOptions): typeof ms;
};
export declare function format(input: number, options?: FormatOptions, language?: LanguageOptions): string | null;
export declare function parse(input: string, _options?: ParseOptions, language?: LanguageOptions): number | null;
/** Options to pass to the format function. */
export interface FormatOptions {
	/** Include input in the output. */
	includeMs?: boolean;
	/** Include sub input in the output. */
	includeSubMs?: boolean;
	/** Insert commas inbetween each unit. */
	insertCommas?: boolean;
	/** Round the result to the highest unit. */
	roundUp?: boolean;
	/** Use the short names of measurements. */
	shortFormat?: boolean;
}
export interface Language {
	/** The version of 'and' in this language */
	and: string;
	/** The decimal separator this language uses */
	decimal: "," | ".";
	/** Measurement units */
	units: Unit[];
}
export interface LanguageOptions {
	/** The version of 'and' in the language */
	andValue: string;
	/** The decimal separator the language uses */
	decimalSeparator: string;
	/** The key for the selected language */
	key: LanguageKey;
	/** The regex to match lengths of time */
	regex: RegExp;
	/** Whether the language has full short support */
	supportsAbbreviations: boolean;
	/** The thousands separator the language uses */
	thousandsSeparator: string;
	/** The units and their names in the language, as a map */
	units: Record<string, Unit & {
		ms: number;
	}>;
}
export interface ParseOptions {
}
export interface Unit {
	/** Short form of the measurement */
	abbreviation?: string | ((count: number) => string);
	/** Key to identify this unit */
	key: MeasurementKey;
	/** Strings used for the string regex */
	matches: string[];
	/** Long form of the measurement */
	name: string | ((count: number) => string);
}
export type CombinedOptions = FormatOptions & ParseOptions;
export type LanguageKey = keyof typeof languages;
export type MeasurementKey = keyof typeof measurements;
export type UnionOptions = FormatOptions | ParseOptions;
export {
	ms as default,
};