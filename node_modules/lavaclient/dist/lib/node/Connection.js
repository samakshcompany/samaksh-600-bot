"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const promises_1 = require("node:timers/promises");
const ws_1 = require("ws");
const NodeState_1 = require("./NodeState");
const node_util_1 = require("node:util");
const Utils_1 = require("../Utils");
const decoder = new node_util_1.TextDecoder();
const _socket = Symbol("Connection#_socket");
const _reconnectionPromise = Symbol("Connection#_reconnectionPromise");
class Connection {
    constructor(node, info) {
        this.node = node;
        this.info = info;
        this.reconnectTry = 0;
        this.payloadQueue = [];
        this.clientName = this.info.clientName ?? `${Connection.CLIENT_NAME} ${(0, Utils_1.randomId)()}`;
    }
    static { this.CLIENT_NAME = "lavaclient"; }
    get active() {
        const socket = this[_socket];
        return socket != null && socket.readyState === ws_1.WebSocket.OPEN;
    }
    get canReconnect() {
        const maxTries = this.info.reconnect?.tries === -1 ? Infinity : this.info.reconnect?.tries ?? 5;
        return Boolean(this.info.reconnect) && maxTries > this.reconnectTry;
    }
    get uptime() {
        if (!this.connectedAt)
            return -1;
        return Date.now() - this.connectedAt;
    }
    send(important, data) {
        return new Promise((resolve, reject) => {
            const payload = { resolve, reject, data };
            this.active
                ? this._send(payload)
                : this.payloadQueue[important ? "unshift" : "push"](payload);
        });
    }
    connect() {
        this.disconnect();
        const userId = this.node.userId;
        if (!userId) {
            throw new Error("No User-Id is present.");
        }
        const headers = {
            Authorization: this.info.password,
            "User-Id": userId,
            "Client-Name": this.clientName,
            "Num-Shards": "1",
        };
        if (this.info.resuming?.key) {
            headers["Resume-Key"] = this.info.resuming.key;
        }
        if (this.node.state !== NodeState_1.NodeState.Reconnecting) {
            this.node.state = NodeState_1.NodeState.Connecting;
            this.node.debug("connection", "creating websocket...");
        }
        const socket = new ws_1.WebSocket(`ws${this.info.secure ? "s" : ""}://${this.info.host}:${this.info.port}`, { headers: headers });
        socket.onopen = this._onopen.bind(this);
        socket.onclose = this._onclose.bind(this);
        socket.onerror = this._onerror.bind(this);
        socket.onmessage = this._onmessage.bind(this);
        this[_socket] = socket;
        this.connectedAt = Date.now();
    }
    disconnect(code = 1000, reason = "closing") {
        if (!this.active) {
            return;
        }
        this.node.state = NodeState_1.NodeState.Disconnecting;
        this.node.debug("connection", `disconnecting... code=${code}, reason=${reason}`);
        this[_socket]?.close(code, reason);
    }
    async configureResuming() {
        if (!this.info.resuming) {
            return;
        }
        await this.send(true, {
            op: "configureResuming",
            key: this.info.resuming.key,
            timeout: this.info.resuming.timeout ?? 60000,
        });
    }
    flushQueue() {
        if (!this.active) {
            return;
        }
        this.payloadQueue.forEach(this._send.bind(this));
        this.payloadQueue = [];
    }
    async reconnect() {
        this.node.state = NodeState_1.NodeState.Reconnecting;
        return new Promise(res => {
            this[_reconnectionPromise] = res;
            try {
                this.connect();
            }
            catch (e) {
                this.node.emit("error", e instanceof Error ? e : new Error(`${e}`));
                return res(false);
            }
        });
    }
    async _onopen() {
        this[_reconnectionPromise]?.(true);
        await this.flushQueue();
        await this.configureResuming();
        this.node.emit("connect", { took: this.uptime, reconnect: this.node.state === NodeState_1.NodeState.Reconnecting });
        this.node.debug("connection", `connected in ${this.uptime}ms`);
        this.node.state = NodeState_1.NodeState.Connected;
    }
    async _onclose({ reason, code, wasClean }) {
        if (this.node.state === NodeState_1.NodeState.Reconnecting) {
            return;
        }
        const reconnecting = this.canReconnect && this.node.state !== NodeState_1.NodeState.Disconnecting;
        this.node.emit("disconnect", { code, reason, wasClean, reconnecting });
        if (!reconnecting) {
            this.node.debug("connection", "unable to reconnect");
            this.node.emit("closed");
            this.node.state = NodeState_1.NodeState.Disconnected;
            return;
        }
        while (!await this.reconnect()) {
            this.reconnectTry++;
            if (!this.canReconnect) {
                this.node.debug("connection", "ran out of reconnect tries.");
                this.node.emit("closed");
                this.node.state = NodeState_1.NodeState.Disconnected;
                return;
            }
            const duration = typeof this.info.reconnect?.delay === "function"
                ? await this.info.reconnect.delay(this.reconnectTry)
                : this.info.reconnect?.delay ?? 10000;
            this.node.debug("connection", `attempting to reconnect in ${duration}ms, try=${this.reconnectTry}`);
            await (0, promises_1.setTimeout)(duration);
        }
    }
    _onerror(event) {
        this[_reconnectionPromise]?.(false);
        const error = event.error ? event.error : event.message;
        this.node.emit("error", new Error(error));
    }
    _onmessage({ data }) {
        if (Array.isArray(data)) {
            data = Buffer.concat(data);
        }
        const text = typeof data === "string"
            ? data
            : decoder.decode(data);
        let payload;
        try {
            payload = JSON.parse(text);
        }
        catch (e) {
            this.node.emit("error", e instanceof Error ? e : new Error(`${e}`));
            return;
        }
        if (payload.op === "stats") {
            this.node.stats = payload;
        }
        else {
            const player = this.node.players.get(payload.guildId);
            if (player) {
                if (payload.op === "playerUpdate") {
                    player.connected = payload.state.connected ?? player.connected;
                    player.lastPosition = payload.state.position;
                    player.lastUpdate = Date.now();
                }
                else {
                    player.handleEvent(payload);
                }
            }
        }
        this.node.debug("connection", `${Connection.CLIENT_NAME} <<< ${payload.op}: ${text}`);
        this.node.emit("raw", payload);
    }
    _send({ data, reject, resolve }) {
        const json = JSON.stringify(data);
        this.node.debug("connection", `${Connection.CLIENT_NAME} >>> ${data.op}: ${json}`);
        return this[_socket]?.send(json, e => e ? reject(e) : resolve());
    }
}
exports.Connection = Connection;
