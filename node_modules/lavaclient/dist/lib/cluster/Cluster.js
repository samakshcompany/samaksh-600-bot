"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cluster = void 0;
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
const Utils_1 = require("../Utils");
const ClusterNode_1 = require("./ClusterNode");
class Cluster extends tiny_typed_emitter_1.TypedEmitter {
    constructor(options) {
        super();
        this.sendGatewayPayload = options.sendGatewayPayload;
        this.userId = options.user && (0, Utils_1.getId)(options.user);
        this.nodes = new Map(options.nodes.map(n => [n.id, new ClusterNode_1.ClusterNode(this, n.id, n)]));
    }
    get rest() {
        return this.idealNodes[0]?.rest ?? null;
    }
    get idealNodes() {
        return [...this.nodes.values()]
            .filter(node => node.conn.active)
            .sort((a, b) => a.penalties - b.penalties);
    }
    connect(user = this.userId) {
        this.userId ??= user && (0, Utils_1.getId)(user);
        for (const [, node] of this.nodes) {
            node.connect(this.userId);
        }
    }
    createPlayer(guild, nodeId) {
        const node = nodeId ? this.nodes.get(nodeId) : this.idealNodes[0];
        if (!node)
            throw new Error("No available nodes.");
        return node.createPlayer(guild);
    }
    getPlayer(guild) {
        const guildId = (0, Utils_1.getId)(guild);
        return this.getNode(guildId)?.players?.get(guildId) ?? null;
    }
    async destroyPlayer(guild) {
        const destroyed = await this.getNode(guild)?.destroyPlayer(guild);
        return destroyed ?? false;
    }
    async handleVoiceUpdate(update) {
        const accepted = await this.getNode(update.guild_id)?.handleVoiceUpdate(update);
        return accepted ?? false;
    }
    getNode(guild) {
        const guildId = (0, Utils_1.getId)(guild);
        return [...this.nodes.values()].find(n => n.players.has(guildId)) ?? null;
    }
}
exports.Cluster = Cluster;
