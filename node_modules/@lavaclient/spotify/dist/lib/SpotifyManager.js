"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpotifyManager = void 0;
const undici_1 = require("undici");
const SpotifyItem_1 = require("./abstract/SpotifyItem");
const SpotifyAlbumLoader_1 = require("./item/SpotifyAlbumLoader");
const SpotifyPlaylistLoader_1 = require("./item/SpotifyPlaylistLoader");
const SpotifyTrackLoader_1 = require("./item/SpotifyTrackLoader");
const SpotifyArtistLoader_1 = require("./item/SpotifyArtistLoader");
class SpotifyManager {
    constructor(lavaclient, options) {
        this.#token = null;
        this.manager = lavaclient;
        this.dispatcher = new undici_1.Pool(SpotifyManager.API_URL);
        this.options = Object.assign(SpotifyManager.DEFAULTS, options);
        this.loaders = [
            new SpotifyAlbumLoader_1.SpotifyAlbumLoader(this.options.pages.album),
            new SpotifyPlaylistLoader_1.SpotifyPlaylistLoader(this.options.pages.playlist),
            new SpotifyTrackLoader_1.SpotifyTrackLoader(),
            new SpotifyArtistLoader_1.SpotifyArtistLoader(),
        ].filter(l => this.options.loaders.includes(l.itemType) ?? false);
        this.searchPrefix =
            SpotifyManager.SOURCE_PREFIX[options.searchPrefix ?? "youtube"];
        this.#client = options.client;
    }
    static { this.API_URL = "https://api.spotify.com"; }
    static { this.DEFAULT_PAGE_STRATEGY = {
        type: "sequential",
        size: 100,
        limit: 10
    }; }
    static { this.SOURCE_PREFIX = {
        youtube: "ytsearch:",
        "youtube music": "ytmsearch:",
        soundcloud: "scsearch:",
    }; }
    static { this.DEFAULTS = {
        autoResolveYoutubeTracks: false,
        pages: {
            album: SpotifyManager.DEFAULT_PAGE_STRATEGY,
            playlist: SpotifyManager.DEFAULT_PAGE_STRATEGY
        },
        loaders: [
            SpotifyItem_1.SpotifyItemType.Album,
            SpotifyItem_1.SpotifyItemType.Artist,
            SpotifyItem_1.SpotifyItemType.Track,
            SpotifyItem_1.SpotifyItemType.Playlist,
        ],
        market: "US",
        searchFormat: "{track} {artist}",
        searchPrefix: "youtube",
    }; }
    #token;
    #client;
    get token() {
        return this.#token;
    }
    get encoded() {
        return Buffer.from(`${this.#client.id}:${this.#client.secret}`).toString("base64");
    }
    isSpotifyUrl(url) {
        const matchers = this.loaders.reduce((rs, loader) => [...rs, ...loader.matchers], []);
        return matchers.some(r => r.test(url));
    }
    async makeRequest(endpoint) {
        if (!this.#token) {
            await this.renew();
        }
        const response = await this.dispatcher.request({
            path: `/v1/${endpoint.replace(/^\//, "")}`,
            method: "GET",
            headers: { "Authorization": `Bearer ${this.token}` }
        });
        return response.body.json();
    }
    async load(url) {
        if (!this.isSpotifyUrl(url)) {
            return null;
        }
        const loader = this.loaders.find(l => l.matchers.some(r => r.test(url)));
        if (!loader) {
            return null;
        }
        const item = await loader.load(this, loader.match(url));
        if (!item) {
            return null;
        }
        if (this.options.autoResolveYoutubeTracks) {
            switch (item.type) {
                case SpotifyItem_1.SpotifyItemType.Album:
                case SpotifyItem_1.SpotifyItemType.Artist:
                case SpotifyItem_1.SpotifyItemType.Playlist:
                    await item.resolveYoutubeTracks();
                    break;
                case SpotifyItem_1.SpotifyItemType.Track:
                    await item.resolveYoutubeTrack();
                    break;
            }
        }
        return item;
    }
    async renew() {
        const response = await (0, undici_1.fetch)("https://accounts.spotify.com/api/token?grant_type=client_credentials", {
            method: "POST",
            headers: {
                authorization: `Basic ${this.encoded}`,
                "content-type": "application/x-www-form-urlencoded",
            }
        });
        const token = await response.json();
        if (!token.access_token) {
            throw new Error("Invalid spotify client id.");
        }
        this.#token = token.access_token;
        setTimeout(() => void this.renew(), token.expires_in * 1000);
    }
}
exports.SpotifyManager = SpotifyManager;
